// https://github.com/rust-lang/docs.rs/blob/2f67be0ed1f3c8d84d2a6c48b7d102598090d864/src/web/rustdoc.rs#L357

use std::path::PathBuf;

use anyhow::Result;
use tracing::{instrument, trace};

pub fn generate_rust_rs_docs(url: String, dir: PathBuf) -> Result<String> {
    // since we directly use the Uri-path and not the extracted params from the router,
    // we have to percent-decode the string here.
    let original_path = percent_encoding::percent_decode(url.as_bytes())
        .decode_utf8()
        .map_err(|_| anyhow::anyhow!("failed to decode url"))?;

    let mut req_path: Vec<&str> = original_path.split('/').collect();
    // Remove the empty start, the name and the version from the path
    req_path.drain(..3).for_each(drop);

    // Pages generated by Rustdoc are not ready to be served with a CSP yet.
    // csp.suppress(true);

    // Convenience function to allow for easy redirection
    // #[instrument]
    // fn redirect(
    //     name: &str,
    //     vers: &str,
    //     path: &[&str],
    //     cache_policy: CachePolicy,
    // ) -> AxumResult<AxumResponse> {
    //     trace!("redirect");
    //     // Format and parse the redirect url
    //     Ok(axum_cached_redirect(
    //         encode_url_path(&format!("/{}/{}/{}", name, vers, path.join("/"))),
    //         cache_policy,
    //     )?
    //     .into_response())
    // }

    trace!("match version");
    // rendering_time.step("match version");

    // let mut conn = pool.get_async().await?;

    // Check the database for releases with the requested version while doing the following:
    // * If no matching releases are found, return a 404 with the underlying error
    // Then:
    // * If both the name and the version are an exact match, return the version of the crate.
    // * If there is an exact match, but the requested crate name was corrected (dashes vs. underscores), redirect to the corrected name.
    // * If there is a semver (but not exact) match, redirect to the exact version.
    // let release_found = match_version(&mut conn, &params.name, Some(&params.version)).await?;
    // trace!(?release_found, "found release");

    //   let (version, version_or_latest, is_latest_url) = match release_found.version {
    //     MatchSemver::Exact((version, _)) => {
    //         // Redirect when the requested crate name isn't correct
    //         if let Some(name) = release_found.corrected_name {
    //             return redirect(&name, &version, &req_path, CachePolicy::NoCaching);
    //         }

    //         (version.clone(), version, false)
    //     }

    //     MatchSemver::Latest((version, _)) => {
    //       // Redirect when the requested crate name isn't correct
    //       if let Some(name) = release_found.corrected_name {
    //           return redirect(&name, "latest", &req_path, CachePolicy::NoCaching);
    //       }

    //       (version, "latest".to_string(), true)
    //     }
    //       // Redirect when the requested version isn't correct
    //       MatchSemver::Semver((v, _)) => {
    //         // to prevent cloudfront caching the wrong artifacts on URLs with loose semver
    //         // versions, redirect the browser to the returned version instead of loading it
    //         // immediately
    //         return redirect(&params.name, &v, &req_path, CachePolicy::ForeverInCdn);
    //     }
    // };

    trace!("crate details");
    // rendering_time.step("crate details");

    // Get the crate's details from the database
    // NOTE: we know this crate must exist because we just checked it above (or else `match_version` is buggy)
    // let krate = CrateDetails::new(
    //     &mut conn,
    //     &params.name,
    //     &version,
    //     &version_or_latest,
    //     Some(&updater),
    // )
    // .await?
    // .ok_or(AxumNope::ResourceNotFound)?;

    //   if !krate.rustdoc_status {
    //     rendering_time.step("redirect to crate");
    //     return Ok(axum_cached_redirect(
    //         format!("/crate/{}/{}", params.name, version_or_latest),
    //         CachePolicy::ForeverInCdn,
    //     )?
    //     .into_response());
    // }

    // let mut rustdoc = Rustdoc::new();
    // rustdoc.generate();

    // if visiting the full path to the default target, remove the target from the path
    // expects a req_path that looks like `[/:target]/.*`
    // if req_path.first().copied() == Some(&krate.metadata.default_target) {
    //   return redirect(
    //       &params.name,
    //       &version_or_latest,
    //       &req_path[1..],
    //       CachePolicy::ForeverInCdn,
    //   );
    // }

    // Create the path to access the file from
    let mut storage_path = req_path.join("/");
    if storage_path.ends_with('/') {
        req_path.pop(); // get rid of empty string
        storage_path.push_str("index.html");
        req_path.push("index.html");
    }

    trace!(?storage_path, ?req_path, "try fetching from storage");

    // record the data-fetch step
    // until we re-add it below inside `fetch_rustdoc_file`
    // rendering_time.step("fetch from storage");

    // Attempt to load the file from the database
    // let blob =
    // let blob = match storage
    //     .fetch_rustdoc_file(
    //         &params.name,
    //         &version,
    //         krate.latest_build_id.unwrap_or(0),
    //         &storage_path,
    //         krate.archive_storage,
    //         Some(&mut rendering_time),
    //     )
    //     .await
    // {
    //     Ok(file) => file,
    //     Err(err) => {
    //         if !matches!(err.downcast_ref(), Some(AxumNope::ResourceNotFound))
    //             && !matches!(err.downcast_ref(), Some(crate::storage::PathNotFoundError))
    //         {
    //             debug!("got error serving {}: {}", storage_path, err);
    //         }
    //         // If it fails, we try again with /index.html at the end
    //         storage_path.push_str("/index.html");
    //         req_path.push("index.html");

    //         return if storage
    //             .rustdoc_file_exists(
    //                 &params.name,
    //                 &version,
    //                 krate.latest_build_id.unwrap_or(0),
    //                 &storage_path,
    //                 krate.archive_storage,
    //             )
    //             .await?
    //         {
    //             redirect(
    //                 &params.name,
    //                 &version_or_latest,
    //                 &req_path,
    //                 CachePolicy::ForeverInCdn,
    //             )
    //         } else if req_path.first().map_or(false, |p| p.contains('-')) {
    //             // This is a target, not a module; it may not have been built.
    //             // Redirect to the default target and show a search page instead of a hard 404.
    //             Ok(axum_cached_redirect(
    //                 encode_url_path(&format!(
    //                     "/crate/{}/{}/target-redirect/{}",
    //                     params.name,
    //                     version,
    //                     req_path.join("/")
    //                 )),
    //                 CachePolicy::ForeverInCdn,
    //             )?
    //             .into_response())
    //         } else {
    //             if storage_path == format!("{}/index.html", krate.target_name) {
    //                 error!(
    //                     krate = params.name,
    //                     version,
    //                     original_path = original_path.as_ref(),
    //                     storage_path,
    //                     "Couldn't find crate documentation root on storage.
    //                     Something is wrong with the build."
    //                 )
    //             }

    //             Err(AxumNope::ResourceNotFound)
    //         };
    //     }
    // };

    Ok("".into())
}
