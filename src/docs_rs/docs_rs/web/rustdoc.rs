// https://github.com/rust-lang/docs.rs/blob/2f67be0ed1f3c8d84d2a6c48b7d102598090d864/src/web/rustdoc.rs#L357

use std::path::PathBuf;

use anyhow::Result;
use log::trace;
use serde::Deserialize;

pub fn generate_rust_rs_docs(url: String, dir: PathBuf) -> Result<()> {
    // since we directly use the Uri-path and not the extracted params from the router,
    // we have to percent-decode the string here.
    let original_path = percent_encoding::percent_decode(url.as_bytes())
        .decode_utf8()
        .map_err(|_| anyhow::anyhow!("failed to decode url"))?;

    let mut req_path: Vec<&str> = original_path.split('/').collect();
    // Remove the empty start, the name and the version from the path
    req_path.drain(..3).for_each(drop);

    // Pages generated by Rustdoc are not ready to be served with a CSP yet.
    // csp.suppress(true);

    // Convenience function to allow for easy redirection
    // #[instrument]
    // fn redirect(
    //     name: &str,
    //     vers: &str,
    //     path: &[&str],
    //     cache_policy: CachePolicy,
    // ) -> AxumResult<AxumResponse> {
    //     trace!("redirect");
    //     // Format and parse the redirect url
    //     Ok(axum_cached_redirect(
    //         encode_url_path(&format!("/{}/{}/{}", name, vers, path.join("/"))),
    //         cache_policy,
    //     )?
    //     .into_response())
    // }

    trace!("match version");
    // rendering_time.step("match version");

    // let mut conn = pool.get_async().await?;

    // Check the database for releases with the requested version while doing the following:
    // * If no matching releases are found, return a 404 with the underlying error
    // Then:
    // * If both the name and the version are an exact match, return the version of the crate.
    // * If there is an exact match, but the requested crate name was corrected (dashes vs. underscores), redirect to the corrected name.
    // * If there is a semver (but not exact) match, redirect to the exact version.
    // let release_found = match_version(&mut conn, &params.name, Some(&params.version)).await?;
    // trace!(?release_found, "found release");

    //   let (version, version_or_latest, is_latest_url) = match release_found.version {
    //     MatchSemver::Exact((version, _)) => {
    //         // Redirect when the requested crate name isn't correct
    //         if let Some(name) = release_found.corrected_name {
    //             return redirect(&name, &version, &req_path, CachePolicy::NoCaching);
    //         }

    //         (version.clone(), version, false)
    //     }

    //     MatchSemver::Latest((version, _)) => {
    //       // Redirect when the requested crate name isn't correct
    //       if let Some(name) = release_found.corrected_name {
    //           return redirect(&name, "latest", &req_path, CachePolicy::NoCaching);
    //       }

    //       (version, "latest".to_string(), true)
    //     }
    //       // Redirect when the requested version isn't correct
    //       MatchSemver::Semver((v, _)) => {
    //         // to prevent cloudfront caching the wrong artifacts on URLs with loose semver
    //         // versions, redirect the browser to the returned version instead of loading it
    //         // immediately
    //         return redirect(&params.name, &v, &req_path, CachePolicy::ForeverInCdn);
    //     }
    // };

    trace!("crate details");
    // rendering_time.step("crate details");

    // Get the crate's details from the database
    // NOTE: we know this crate must exist because we just checked it above (or else `match_version` is buggy)
    // let krate = CrateDetails::new(
    //     &mut conn,
    //     &params.name,
    //     &version,
    //     &version_or_latest,
    //     Some(&updater),
    // )
    // .await?
    // .ok_or(AxumNope::ResourceNotFound)?;

    //   if !krate.rustdoc_status {
    //     rendering_time.step("redirect to crate");
    //     return Ok(axum_cached_redirect(
    //         format!("/crate/{}/{}", params.name, version_or_latest),
    //         CachePolicy::ForeverInCdn,
    //     )?
    //     .into_response());
    // }

    // let mut rustdoc = Rustdoc::new();
    // rustdoc.generate();

    // if visiting the full path to the default target, remove the target from the path
    // expects a req_path that looks like `[/:target]/.*`
    // if req_path.first().copied() == Some(&krate.metadata.default_target) {
    //   return redirect(
    //       &params.name,
    //       &version_or_latest,
    //       &req_path[1..],
    //       CachePolicy::ForeverInCdn,
    //   );
    // }

    // Create the path to access the file from
    let mut storage_path = req_path.join("/");
    if storage_path.ends_with('/') {
        req_path.pop(); // get rid of empty string
        storage_path.push_str("index.html");
        req_path.push("index.html");
    }

    trace!("{:?} {:?} fetch from storage", storage_path, req_path);

    // record the data-fetch step
    // until we re-add it below inside `fetch_rustdoc_file`
    // rendering_time.step("fetch from storage");

    // Attempt to load the file from the database
    // let blob = match storage
    //     .fetch_rustdoc_file(
    //         &params.name,
    //         &version,
    //         krate.latest_build_id.unwrap_or(0),
    //         &storage_path,
    //         krate.archive_storage,
    //         Some(&mut rendering_time),
    //     )
    //     .await
    // {
    //     Ok(file) => file,
    //     Err(err) => {
    //         if !matches!(err.downcast_ref(), Some(AxumNope::ResourceNotFound))
    //             && !matches!(err.downcast_ref(), Some(crate::storage::PathNotFoundError))
    //         {
    //             debug!("got error serving {}: {}", storage_path, err);
    //         }
    //         // If it fails, we try again with /index.html at the end
    //         storage_path.push_str("/index.html");
    //         req_path.push("index.html");

    //         return if storage
    //             .rustdoc_file_exists(
    //                 &params.name,
    //                 &version,
    //                 krate.latest_build_id.unwrap_or(0),
    //                 &storage_path,
    //                 krate.archive_storage,
    //             )
    //             .await?
    //         {
    //             redirect(
    //                 &params.name,
    //                 &version_or_latest,
    //                 &req_path,
    //                 CachePolicy::ForeverInCdn,
    //             )
    //         } else if req_path.first().map_or(false, |p| p.contains('-')) {
    //             // This is a target, not a module; it may not have been built.
    //             // Redirect to the default target and show a search page instead of a hard 404.
    //             Ok(axum_cached_redirect(
    //                 encode_url_path(&format!(
    //                     "/crate/{}/{}/target-redirect/{}",
    //                     params.name,
    //                     version,
    //                     req_path.join("/")
    //                 )),
    //                 CachePolicy::ForeverInCdn,
    //             )?
    //             .into_response())
    //         } else {
    //             if storage_path == format!("{}/index.html", krate.target_name) {
    //                 error!(
    //                     krate = params.name,
    //                     version,
    //                     original_path = original_path.as_ref(),
    //                     storage_path,
    //                     "Couldn't find crate documentation root on storage.
    //                     Something is wrong with the build."
    //                 )
    //             }

    //             Err(AxumNope::ResourceNotFound)
    //         };
    //     }
    // };

    // Serve non-html files directly
    if !storage_path.ends_with(".html") {
        trace!("{:?}", storage_path);
        // rendering_time.step("serve asset");

        // default asset caching behaviour is `Cache::ForeverInCdnAndBrowser`.
        // This is an edge-case when we serve invocation specific static assets under `/latest/`:
        // https://github.com/rust-lang/docs.rs/issues/1593
        // return Ok(File(blob).into_response());
        return Err(anyhow::anyhow!("serve asset"));
    }

    // rendering_time.step("find latest path");

    // let latest_release = krate.latest_release();

    // Get the latest version of the crate
    // let latest_version = latest_release.version.to_string();
    // let is_latest_version = latest_version == version;
    // let is_prerelease = !(semver::Version::parse(&version)
    //     .with_context(|| {
    //         format!(
    //             "invalid semver in database for crate {}: {}",
    //             params.name, &version
    //         )
    //     })?
    //     .pre
    //     .is_empty());

    // The path within this crate version's rustdoc output
    //   let (target, inner_path) = {
    //     let mut inner_path = req_path.clone();

    //     let target = if inner_path.len() > 1
    //         && krate
    //             .metadata
    //             .doc_targets
    //             .iter()
    //             .any(|s| s == inner_path[0])
    //     {
    //         inner_path.remove(0)
    //     } else {
    //         ""
    //     };

    //     (target, inner_path.join("/"))
    // };

    Ok(())
}

#[derive(Clone, Deserialize, Debug)]
pub(crate) struct RustdocHtmlParams {
    pub(crate) name: String,
    pub(crate) version: String,
    // both target and path are only used for matching the route.
    // The actual path is read from the request `Uri` because
    // we have some static filenames directly in the routes.
    pub(crate) target: Option<String>,
    pub(crate) path: Option<String>,
}
